"""
WIP - Work in Progress
This Module tries to fuse both GenomeLibrary and GenomeSequence together. Change on one will affect
the other part. When done, it aims to replace GenomeLibrary and add Sequence support.
"""


from __future__ import annotations
from copy import copy
from typing import Optional, Set, List, NamedTuple

from numpy.random import Generator
from Bio import pairwise2
from Bio.Seq import Seq
from Bio.Blast.Record import Alignment
from Bio.Align import PairwiseAligner

from ....organism import Organism
from ....module import Module
from ..records.gene import Gene
from ..events import InsertGeneEvent, RemoveGeneEvent



class LocGene (NamedTuple) :
    gene: Gene
    loc: int


class PrimerMatch (NamedTuple) :
    loc_start: int # Match goes from start (inclusive) to end (exclusive).
    loc_end: int
    success: float # (0,1)



class SimpleGenome (Module) :
    """
    SimpleGenome is a module that models the genome in a simplified way to ease interpretation.
    It can store a list of genes and display them in a sequence alongside background bases.

    Genes that overlap each other will be place in sequence.

    The Gene list and the Sequence exist as equals. When one operation changes the Gene list, the
    Sequence is affected. Likewise, if an operation changes the Sequence, the Gene list is affected.
    """

    bg_min_size: int # Minimum number of background gene bases.

    bg_gc_content: float # Ratio of GC-content in the background genome. Range: [0,1]

    locgenes: List[LocGene]

    sequence: Seq



    def __init__ ( self, org:Organism, ref:Optional[SimpleGenome] = None ) :
        super().__init__(org,ref)

        if ref is not None :
            self.genes = copy(ref.genes)
            self.sequence = build_sequence
        else :
            self.genes = dict()

        self.org.observe( InsertGeneEvent, self.listen_insert_gene )
        #self.org.observe( RemoveGeneEvent, self.listen_remove_gene )



    def listen_insert_gene ( self, event:InsertGeneEvent ) -> None :
        self.genes[event.gene] = GeneAndLocus( gene=event.gene, locus=event.locus )
        print( "Added gene={} locus={} to the GenomeLibrary.".format(
            event.gene.get_name(), event.locus
        ))



    def listen_remove_gene ( self, event:RemoveGeneEvent ) -> None :
        """ Remove a gene from the library and sequence. """
        del self.genes[event.gene]
        print( "Removed gene={} from the GenomeLibrary.".format(event.gene.get_name()) )



    def insert_gene ( self, gene:Gene, loc:int ) :
        """ Insert a gene at a specific location in the sequence. """
        self.sequence = self.sequence[0:loc] + gene.prom + gene.orf + self.sequence[loc:None]
        self.locgenes.append( LocGene( gene=gene, loc=loc ))



    def calc_primer_matches ( self, primer:Seq ) -> List[PrimerMatch] :
        """
        Return the insertion sites a primer can have, alongside with success rate.
        The insertion site is located right after a primer match.
        """
        matches: List[PrimerMatch] = []
        targets: List[Seq] = [ self.sequence ] # List of sequences to check.
        for target in targets :
            match = find_best_primer_match( target, primer )
            if match is not None :
                matches.append( match )
                targets.append( target[None:match.loc_start] ) # Also search left of match.
                targets.append( target[match.loc_end:None] ) # Also search right of match.
        return matches






def make_background_seq ( self, rnd:Generator, size:int, gc_content:float ) -> Seq :
    gc = gc_content
    at = 1 - gc_content
    seq_array = rnd.choice( 'ACGT', size=size, p=[at,gc,gc,at] ) # 'ATCG' is ArrayLike
    return Seq( "".join(seq_array) )



def check_primer_integrity ( primer:Seq ) -> bool :
    """ Non-deterministic check if the primer itself is well built. """
    return True



def find_best_primer_match ( sequence:Seq, primer:Seq ) -> Optional[PrimerMatch] :

    # Build the aligner for matching.
    aligner = PairwiseAligner()
    aligner.mode = 'local' # target_end_gap_score, query_end_gap_score
    aligner.match_score = 1
    aligner.mismatch_score = -1
    aligner.gap_score = -1 # open_gap_score, extend_gap_score

    # Get the alignment with the best score, anywhere on the sequence.
    all_alignments = aligner.align( sequence, primer )
    best_alignment = next(sorted(all_alignments))
    if best_alignment is not None :
        return PrimerMatch(
            loc_start= best_alignment.aligned[0][0][0], # start of first chunk in target
            loc_end= best_alignment.aligned[0][-1][0], # start of last chunk in target
            success= best_alignment.score / len(primer)
        )
    return None





# def build_sequence ( self ) -> Seq :
#     rnd = self.org.make_generator()
#     gc = self.bg_gc_content
#     at = 1 - self.bg_gc_content

#     # Write the sequence from begin to end. Genes have their sequence copied and random bases
#     # are used to fill non-coding positions. Overlapping genes have undefined behaviour.
#     # TODO: When gene positions overlap it actually writes both gene sequences in sequence but
#     # in future this behaviour should be improved. This deals with validity of genes in
#     # overlapping regions.
#     locgenes = self.genes.values()
#     locgenes.sort( key=lambda el: el.locus )

#     seq = Seq()
#     cur = 0
#     bg_size = 0 # Current amount of background bases.
#     for locgene in locgenes :

#         # If the gene starts later, then fill the space with random (background) bases.
#         filler = locgene.locus - cur
#         if filler > 0 :
#             new_bases = rnd.choice( 'ATCG', size=filler, p=[at,at,gc,gc] )
#             bg_size += filler
#             seq += "".join(new_bases)

#         # Copy the gene sequence.
#         seq = seq + locgene.gene.get_prom() + locgene.gene.get_orf()

#     # At the end, if the minimum of background bases was not filled, to that now.
#     filler = min( 0, self.bg_min_size - bg_size )
#     if filler > 0 :
#         new_bases = rnd.choice( 'ATCG', size=filler, p=[at,at,gc,gc] )
#         seq += "".join(new_bases)

#     return seq